<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - GLTFloader + compressed</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>
    <div id="info">
        <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - GLTFLoader + compression
        extensions<br />
        <a href="https://sketchfab.com/3d-models/coffeemat-7fb196a40a6e4697aad9ca2f75c8b33d" target="_blank"
            rel="noopener">Coffeemat</a> by
        <a href="https://sketchfab.com/OFFcours1" target="_blank" rel="noopener">Roman Red</a>
    </div>

    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "./lib/three/src/Three.js",
                "three/addons/": "./lib/three/examples/jsm/"
            }
        }
	</script>

    <script src="lib/tweakpane-3.1.9.min.js"></script>

    <script type="module">

        import * as THREE from 'three';

        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { Lensflare, LensflareElement } from 'three/addons/objects/Lensflare.js';

        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';

        import Bakery01 from './bakery01.js'

        console.log(Bakery01)

        let camera, scene, renderer, ambientLight;
        let controls, loader
        let userScene
        let pane

        let textureLoader = new THREE.TextureLoader()
        const flare0 = textureLoader.load('./assets/texture/lensflare0.png');
        const flare1 = textureLoader.load('./assets/texture/lensflare3.png');

        let state = {
            enabled: true,
            lighting: 1,
            flares: 1,
            punctual: 0,
            ambient: 0,
            environment: 0.1,
            environmentImpact: -0.05
        }

        let secondaryFlaresMap = [
            [60, 0.6],
            [70, 0.7],
            [120, 0.9],
            [70, 0.1]
        ]

        init();

        function init() {
            initRenderer();
            initLoaders();
            initControls();
            initDropZone();
            initGui();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                render();
            });

            loadModel('./assets/Bedroom Interior Design (Baking Test).glb')
        }

        function initRenderer() {
            const container = document.createElement('div');
            document.body.appendChild(container);

            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.LinearToneMapping;
            renderer.toneMappingExposure = 1;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.gammaFactor = 1
            renderer.physicallyCorrectLights = true
            container.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 20);
            camera.position.set(0, 2, 3);

            scene = new THREE.Scene();

            const grid = new THREE.GridHelper(2, 20, 0xffffff, 0xffffff);
            grid.material.opacity = 0.1;
            grid.material.depthWrite = false;
            grid.material.transparent = true;
            grid.position.y = -0.1
            scene.add(grid);

            // ambient light 
            ambientLight = new THREE.AmbientLight(0xeeeeff)
            ambientLight.intensity = state.ambient
            scene.add(ambientLight)

            return new Promise((resolve, reject) => {
                new RGBELoader().load("assets/dikhololo_night_4k.hdr", function (texture) {
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    scene.background = texture;
                    scene.backgroundIntensity = state.environment
                    scene.environment = texture;
                    render
                });
            })
        }

        function initLoaders() {
            const ktx2Loader = new KTX2Loader()
                .setTranscoderPath('lib/three/examples/jsm/libs/basis/')
                .detectSupport(renderer);

            let dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('lib/three/examples/jsm/libs/draco/gltf/');

            loader = new GLTFLoader();
            loader.setDRACOLoader(dracoLoader)
            loader.setKTX2Loader(ktx2Loader);
            loader.setMeshoptDecoder(MeshoptDecoder);
        }

        function initControls() {
            controls = new OrbitControls(camera, renderer.domElement);
            controls.addEventListener('change', render); // use if there is no animation loop
            controls.minDistance = 0.1;
            controls.maxDistance = 5;
            controls.object.position.set(0.06785434410043728, 0.485231926679771, 1.782980065465598)
            controls.target.set(0.0162651718473893, 0.142688604330217, -0.03519590447642134);
            controls.update();

            console.log(controls)
        }

        function initDropZone() {
            let dropZone = document.body;

            dropZone.addEventListener('dragover', function (event) {
                event.stopPropagation();
                event.preventDefault();
                event.dataTransfer.dropEffect = 'copy';
            });

            dropZone.addEventListener('drop', async function (event) {
                event.stopPropagation();
                event.preventDefault();
                console.log(event.dataTransfer.files)
                loadModel(await createBlobURL(event.dataTransfer.files[0]))
            });
        }

        function createBlobURL(file) {
            return new Promise((resolve) => {
                var reader = new FileReader();
                reader.onload = function (event) {
                    var blob = new Blob([event.target.result]);
                    var url = URL.createObjectURL(blob);
                    resolve(url); // call the callback function with the created Blob URL
                };
                reader.onerror = function (event) {
                    console.error("File could not be read! Code " + event.target.error.code);
                };
                reader.readAsArrayBuffer(file);
            })
        }

        function initGui() {
            pane = new Tweakpane.Pane();

            pane.addBlade({
                view: 'list',
                label: 'Mode',
                options: [
                    { text: 'Bakery + Flares', value: 0 },
                    { text: 'Classic Lighting', value: 1 }
                ],
                value: 0

            }).on('change', ({ value }) => {
                console.log(value)
                switch (value) {
                    case 0: {
                        state.enabled = true
                        state.punctual = 0
                        state.lighting = 1
                        state.flares = 1
                        pane.refresh()
                        break;
                    }
                    case 1: {
                        state.enabled = false
                        state.punctual = 16
                        state.lighting = 1
                        state.flares = 0
                        pane.refresh()
                        break;
                    }
                }

                forEachMaterial(userScene, (mat) => {
                    mat.vertexColors = state.enabled
                })

                render()
            })
            pane.addInput(state, 'enabled', { label: 'Bakery Enabled', }).on('change', () => {
                forEachMaterial(userScene, (mat) => {
                    mat.vertexColors = state.enabled
                })
                render()
            })
            pane.addInput(state, 'lighting', { label: 'Baked Lights', min: 0, max: 1, step: 0.05 }).on('change', render)
            pane.addInput(state, 'flares', { label: 'Flares', min: 0, max: 1, step: 0.05 }).on('change', () => {
                forEachLight(userScene, (light) => {
                    light.children.forEach((child) => {
                        if (child.isLensflare) {
                            child.intensity = state.flares * (light.isDirectionalLight ? 2 : 0.5)
                        }
                    })
                })
                render()
            })
            pane.addInput(state, 'punctual', { label: 'Scene Lights', min: 0, max: 16, step: 0.05 }).on('change', render)
            pane.addInput(state, 'ambient', { label: 'Ambient Light', min: 0, max: 1, step: 0.05 }).on('change', () => {
                ambientLight.intensity = state.ambient;
                render();
            })
            pane.addInput(state, 'environment', { label: 'Env Brightness', min: 0, max: 1, step: 0.05 }).on('change', () => {
                scene.backgroundIntensity = state.environment;
                forEachMaterial(userScene, (mat) => {
                    mat.envMapIntensity = state.environment + state.environmentImpact;
                })
                render();
            })
            pane.addInput(state, 'environmentImpact', { label: 'Env Impact', min: -1, max: 1, step: 0.05 }).on('change', () => {
                forEachMaterial(userScene, (mat) => {
                    mat.envMapIntensity = Math.max(0, Math.min(1, state.environment + state.environmentImpact));
                })
                render();
            })
        }

        function forEachMaterial(scene, callback) {
            scene.traverse((item) => {
                if (item.isMesh) {
                    let materials = Array.isArray(item.material) ? item.material : [item.material]
                    materials.forEach((mat) => {
                        console.log(`processing material "${mat.name}"`, mat)
                        callback(mat, item)
                    })
                }
            })
        }

        function forEachLight(scene, callback) {
            scene.traverse((item) => {
                if (item.isLight) {
                    callback(item)
                }
            })
        }


        function addLensFlareToLight(light, secondaryFlares = 4, intensity = 1) {
            const lensflare = new Lensflare(light);
            lensflare.addElement(new LensflareElement(flare0, 700, 0, light.color));
            for (let i = 0; i < secondaryFlares; i++) {
                let flare_data = secondaryFlaresMap[i % secondaryFlaresMap.length]
                lensflare.addElement(new LensflareElement(flare1, flare_data[0], flare_data[1]));
            }


            lensflare.intensity = intensity
            light.add(lensflare)
            return lensflare
        }

        function getDirectoryPath(filePath) {
            let lastSlashPosition = filePath.lastIndexOf('/');
            if (lastSlashPosition === -1) {
                return '';
            }
            return filePath.substring(0, lastSlashPosition);
        }

        function loadModel(filePath) {
            if (userScene != null) {
                userScene.traverse((item) => {
                    if (item.geometry) {
                        item.geometry.dispose()
                    }
                })
                forEachMaterial(userScene, (mat) => mat.dispose())
                scene.remove(userScene);
                userScene = null
            }
            return new Promise((resolve) => {
                let dirPath = getDirectoryPath(filePath)
                let fileName = filePath.replace(dirPath, '');

                loader.setPath(dirPath)

                loader.load(fileName, function (gltf) {
                    userScene = gltf.scene
                    console.log(gltf)

                    // scene scaling and aligning
                    let sphere = new THREE.Sphere();
                    let box = new THREE.Box3().setFromObject(gltf.scene);
                    console.log(box)
                    box.getBoundingSphere(sphere);

                    gltf.scene.scale.setScalar(1 / sphere.radius)

                    box.setFromObject(gltf.scene)
                    box.getBoundingSphere(sphere);
                    gltf.scene.position.set(
                        -sphere.center.x,
                        -box.min.y,
                        -sphere.center.z,
                    )

                    forEachMaterial(userScene, (mat) => {
                        mat.envMapIntensity = state.environment;
                        mat.onBeforeCompile = function (shader) {
                            shader.uniforms.bakedLightIntensity = {
                                get value() {
                                    return state.lighting
                                }
                            }

                            let pars_code = `
                            #if defined(USE_COLOR)
                                uniform float bakedLightIntensity;
                            #endif
                            `
                            let main_code = `
                            #if defined( USE_COLOR )
                                irradiance += (vColor.rgb * 3.14) * bakedLightIntensity;
                                reflectedLight.indirectDiffuse += (vColor.rgb * 3.14) * bakedLightIntensity;
                            #endif
                            `

                            let main_code2 = `
                            #if defined( USE_COLOR )
                                /** stubbed */
                            #endif
                            `

                            shader.fragmentShader = `
                                ${pars_code}
                                ${shader.fragmentShader
                                    .replace("#include <lights_fragment_begin>", `#include <lights_fragment_begin>\n${main_code}`)
                                    .replace("#include <color_fragment>", `${main_code2}\n`)}
                            `
                            console.log(shader)
                            //                     shader.uniforms.customUniform = { value: 0.5 };

                            //                     shader.vertexShader = 'uniform float customUniform;\n' + shader.vertexShader;
                            //                     shader.fragmentShader = 'uniform float customUniform;\n' + shader.fragmentShader;

                            //                     shader.fragmentShader = shader.fragmentShader.replace(
                            //                         `vec4 diffuseColor = vec4( diffuse, opacity );`,
                            //                         `
                            // vec4 diffuseColor = vec4( diffuse, opacity );
                            // diffuseColor.r *= customUniform;
                            // `
                            // );
                        };
                    })

                    // normalizing gltf+three lighting units mess
                    let maxLightIntensity = 0;
                    forEachLight(userScene, (light) => {
                        maxLightIntensity = Math.max(maxLightIntensity, light.intensity)
                    })
                    forEachLight(userScene, (light) => {
                        let normalizedIntensity = light.intensity / maxLightIntensity;
                        light.normalizedIntensity = normalizedIntensity
                        Object.defineProperty(light, 'intensity', {
                            get() {
                                return normalizedIntensity * state.punctual;
                            }
                        })

                        // light.distance = light.distance == 0 ? 1 : light.distance
                        // adding lens flares to each light source
                        addLensFlareToLight(light, light.isDirectionalLight ? 4 : 1, state.flares * (light.isDirectionalLight ? 2 : 0.5))
                    })

                    scene.add(gltf.scene);
                    render()
                    resolve()
                });
            })
        }



        //

        function render() {
            renderer.render(scene, camera);
        }


    </script>

</body>

</html>